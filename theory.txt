Основы ООП и объявление класса в C#

ООП - парадигма программирования, основанная на концепции объектов(поля, методы)

Различают 4 вида:
1. Инкапсуляция - сокрытие внутренних деталей работы и предоставление интерфейса для взаимодействия(пример:
мы пользуемся телевизором, но не знаем как он устроен внутри)
2. Наследование - механизм языка, который позволяет конструировать объект на основе другого уже существующего
3. Полиморфизм - использование функции базового класса для разных типов(функция голос для разных животных
 работает по разному)
4. Абстракция - игнорирование критически важных деталей??????(пример: когда вы водите автомобиль, вы не
 думаете о внутреннем устройстве двигателя, вы просто используете педали и руль)

Отличие класса от структуры в том, что класс - это ссылочный тип, а структура - значимый

Семантика - это смысл отдельных элементов программы, написанных по правилам синтаксиса

Сигнатура - это название метода и аргументов, которые я добавляю

switch работает с неизменяемыми значениями
public ставится в интерфейсе по умолчанию

var нужен для того, чтобы программист не думал, какой тип переменной присвоить

Делегат - это тип данных, который хранит ссылки на методы(реализация отписки и подписки)
Делегат - это безопасный эквивалент указателя на функцию в си

Событие - это обертка для делегата

Неявное от явного преобразования интерфейса(часть механизма инкапсуляции) отличается ограничением видимости
 метаданных

Множественное наследование в С# есть (пример: наследование интерфейсов)

Абстрактный класс — это класс, у которого не реализован один или больше методов
Интерфейс — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных
 класса.

Параметры - это то, что в скобках

Умение правильно выделять абстракции и правильно реализовывать в них часть реализации - это основный принцип 
декомпозиции в ООП

override - это переопределение методов
private доступен только на уровне класса, в наследниках его нет
protected не доступен на уровне экземпляра класса, но доступен в наследниках
virtual - это частичная реализация

виды делегатов:
1. Делегат Action представляет некоторое действие, которое ничего не возвращает, то есть в качестве
 возвращаемого типа имеет тип void
2. Делегат Predicate<T> принимает один параметр и возвращает значение типа bool
3. Func возвращает результат действия и может принимать параметры.


к статичным методам обращаться через название_класса.метод, а к нестатичным через экземпляр_класса.метод

get - set - это свойства или методы доступа

динамические списки работают медленнее, нежели массивы, но гораздо быстрее, если нужно удалять или добавлять
элементы
бинарное дерево обладает нелинейной структурой данных, не более одного предка - бинарный поиск


виды полиморфизма:
параметрический
перегрузка функций и операторов ad hok
полиморфизм подтипов

ключевые слова:

с ref у значимого типа struct - при работе с передаваемой переменной изменяется сам объект 
использовать ref
экземпляр превращается в объект и кладется в кучу - boxing
работает только в пределах стека
с ref мы работаем напрямую, а не копируем
при распаковке упаковке значимых типов происходит 3 преобразования(там еще в конце ссылка передается)

out - нужно инициализировать то, что приходит на вход у метода(аргументу с out должно быть присвоено значение)

in - переменную можно менять, но нельзя ей ничего присваивать

объект предоставляет 4 функционала:
1. tostring - возвращает строку
2. getHashCode - номер 16-битный возвращает, но не адрес объекта
коллизия - это когда hash коды совпадают 
3. getType - получаем тип объекта, пригодится в рефлексии(можно пройтись по типу и изменить данные с этим типом)
typeof - работает напрямую с метаданными типа объекта(обращаемся именно уже созданному экземпляру,
 а в getType еще копия с типом создается(обращаемся к классу в общем)
4. equals - сравнивает hash коды(т е ссылочные типы)

c# - управляемый язык, высокоуровневый, строготипизированный   
с - неуправляемый, нет классов
с++ - средний, управление памятью осуществляется с помощью указателей на функцию

абстрактные классы и интерфейсы нельзя создавать через new()       

служба(сервис) - это класс без состояния, в отличие от сущности, он ничего в себе не хранит, описывает бизнес-процессы

подтип - это класс с sealed

рефлекция - это когда мы заходим внутрь подтипа и изучаем его содержимое, т е меняем поля и методы

метаданные - данные подтипа(хэши, конструкторы, методы и их определители, поля, свойства и их определители и сигнатуры

атрибуты заключаются в квадратные скобки, класс, который дополняет метаданные подтипа

классические атрибуты?

атрибуты необходимы для модификации метаданных и для добавления метаданных

одно из назначений streams(потоков) это чтение файлов

объем оперативной памяти может быть меньше, чем объем файла, т е мы можем прочесть его по частям

 stream - это поток байт(данных), которую можно читать и в которую можно писать, а thread - это когда одновременно выполняются несколько действий у проги
seek - это переход к определенной позиции, с которой начнется чтение

memorystream - конвертация одного формата данных в другой, используется для буферизации неких данных, хранит их в оперативной памяти

2 класса для работы с двоичными данными: binaryreader, binarywriter

у любого сокета есть определенный адрес в сети, через который в него можно попасть

каждый порт может быть занят только одним сокетом

accepttcpclient - метод ждет, когда клиент подключится к серверу


чтобы записать один русский символ необходимо 2 байта, английский - 1, китайский - 4
utf32 - 4 символа
в c# используем utf16
 
thread - это поток выполнения

static - значит есть this и какой-нибудь объект

спам огромным количеством анонимных функций - это плохо, так как они одинаковые
             
существование форматов данных(json) обусловлено тем, что каждая платформа по разному читает данные

формат -это стандартизированное представление данных, которое не зависит от платформы

серилизация - это приведение объекта платформы к формату json 
writeindented(true) - на каждой строке имя - значение переменной
свойства автоматом переводятся в json, с полями же иная ситуация

decimal - позволяет хранить десятичные числа без ошибки округления

tcpSocket.Bind(tcpEndPoint) - сокет слушает только tcppoint

сайт:
1 занятие
промышленная разработка - это принципы солид, юнит тесты, паттерны
agile методология - это users stories, что будет в программе
domain - предметная область

свойство от поля отличается тем, что оно ограничивает доступ
за свойством может скрываться метод, то есть может скрываться за ним проверка чего-либо
guid - это 128 битное уникальное число, которое можно рандомно генерировать

readonly - проинициализированно один раз
внедрение через конструктор

API - application programming interface - то есть, например, мной написаны программы и они предназначены для того, чтобы ими пользовались другие 
пользователи
WEB API - набор методов, которые могут быть применены через протокол http к определенному серверу для получения от него определенной информации
api предоставляет информацию такого рода:
разделяем наше приложение на несколько микросервисных компонентов

active server pages

если я никак не изменяяю элемент , то он должен быть readonly 

navbar - навигационная панель
navbar-brand - большим шрифтом название сайта 
BinaryWriter - адаптер паттерн , который позволяет один интерфейс привести к другому

bool TryGetValue(K key, out V value): получает из словаря элемент по ключу key. При успешном получении передает значение элемента в выходной
 параметр value и возвращает true


	
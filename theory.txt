Основы ООП и объявление класса в C#

ООП - парадигма программирования, основанная на концепции объектов(поля, методы)

Различают 4 вида:
1. Инкапсуляция - сокрытие внутренних деталей работы и предоставление интерфейса для взаимодействия(пример:
мы пользуемся телевизором, но не знаем как он устроен внутри)
2. Наследование - механизм языка, который позволяет конструировать объект на основе другого уже существующего
3. Полиморфизм - использование функции базового класса для разных типов(функция голос для разных животных
 работает по разному)
4. Абстракция - игнорирование критически важных деталей??????(пример: когда вы водите автомобиль, вы не
 думаете о внутреннем устройстве двигателя, вы просто используете педали и руль)

Отличие класса от структуры в том, что класс - это ссылочный тип, а структура - значимый

Семантика - это смысл отдельных элементов программы, написанных по правилам синтаксиса

Сигнатура - это название метода и аргументов, которые я добавляю

switch работает с неизменяемыми значениями
public ставится в интерфейсе по умолчанию

var нужен для того, чтобы программист не думал, какой тип переменной присвоить

Делегат - это тип данных, который хранит ссылки на методы(реализация отписки и подписки)
ссылается на методы
Делегат - это безопасный эквивалент эквивалент указателя на функцию в си

Событие - это обертка для делегата

Неявное от явного преобразования интерфейса(часть механизма инкапсуляции) отличается ограничением видимости
 метаданных

Множественное наследование в С# есть (пример: наследование интерфейсов)

Абстрактный класс — это класс, у которого не реализован один или больше методов
Интерфейс — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных
 класса.

Параметры - это то, что в скобках

Умение правильно выделять абстракции и правильно реализовывать в них часть реализации - это основный принцип 
декомпозиции в ООП

override - это переопределение методов
private доступен только на уровне класса, в наследниках его нет
protected не доступен на уровне экземпляра класса, но доступен в наследниках
virtual - это частичная реализация

виды делегатов:
1. Делегат Action представляет некоторое действие, которое ничего не возвращает, то есть в качестве
 возвращаемого типа имеет тип void
2. Делегат Predicate<T> принимает один параметр и возвращает значение типа bool
3. Func возвращает результат действия и может принимать параметры.


к статичным методам обращаться через название_класса.метод, а к нестатичным через экземпляр_класса.метод

get - set - это свойства или методы доступа

динамические списки работают медленнее, нежели массивы, но гораздо быстрее, если нужно удалять или добавлять
элементы
бинарное дерево обладает нелинейной структурой данных, не более одного предка - бинарный поиск


виды полиморфизма:
параметрический
перегрузка функций и операторов ad hok
полиморфизм подтипов

ключевые слова:

с ref у значимого типа struct - при работе с передаваемой переменной изменяется сам объект 
использовать ref
экземпляр превращается в объект и кладется в кучу - boxing
работает только в пределах стека
с ref мы работаем напрямую, а не копируем
при распаковке упаковке значимых типов происходит 3 преобразования(там еще в конце ссылка передается)

out - нужно инициализировать то, что приходит на вход у метода(аргументу с out должно быть присвоено значение)

in - переменную можно менять, но нельзя ей ничего присваивать

объект предоставляет 4 функционала:
1. tostring - возвращает строку
2. getHashCode - номер 16-битный возвращает, но не адрес объекта
коллизия - это когда hash коды совпадают 
3. getType - получаем тип объекта, пригодится в рефлексии(можно пройтись по типу и изменить данные с этим типом)
typeof - работает напрямую с метаданными типа объекта(обращаемся именно уже созданному экземпляру,
 а в getType еще копия с типом создается(обращаемся к классу в общем)
4. equals - сравнивает hash коды(т е ссылочные типы)

c# - управляемый язык, высокоуровневый, строготипизированный   
с - неуправляемый, нет классов
с++ - средний, управление памятью осуществляется с помощью указателей на функцию

абстрактные классы и интерфейсы нельзя создавать через new()                     